---
layout: post
title: "클린코드와 리팩토링"
date: 2023-12-28
category: 세미나
---

# 클린코드
## 클린코드란?

- 버그가 생기지 않고 읽기 쉬운 코드를 뜻함
  - 깨끗한 코드는 한 가지를 제대로 한다. - 비야네 스트롭스트룹(C++ 창시자)
  - 깨끗한 코드는 잘 쓴 문장처럼 읽힌다. - 그레디 부치
  - 특정 목적을 달성하는 방법은 (여러가지가 아닌)하나만 제공한다. - 데이브 토마스
  - 깨끗한 코드는 언제나 누군가 주의 깊게 짰다는 느낌을 준다. - 마이클 페더즈
  - 깨끗한 코드를 만드는 비결은 중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기. - 론 제프리
  - 코드가 짐작한 대로 기능을 수행한다면 깨끗한 코드라 불러도 되겠다. <br> 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다. - 워드 커닝엄

- ### 클린 코드는 왜 중요할까?
    **읽기 10 : 1 쓰기**
    - 코드를 작성할 때, 코드를 읽는 것과 코드를 쓰는 것에 투자 하는 비율은 10:1 정도 된다고 한다. 때문에 코드를 쉽게 짜기 위해서 코드는 읽기 쉽게 만들어야 함.
    - 읽기 쉬운 코드를 짜는 것은 쉽지 않지만, 읽기 쉬운 코드를 짜야 코드를 짜는게 쉬워짐

- ### 읽기 쉬운 코드(가독성)
    - 코드는 이해 하기 쉬워야 함
    - 내가 아닌 다른 사람이 그것을 이해 하는데 들이는 시간을 최소화 하는 방식으로 작성 하기
    - 1회용 코드는 피하기(WORN: Write Once Read Never)

## 클린 코드 짜기
  - ### OCP(Open-Closed Principle)
    - 소프트웨어 개체는 확장에 열려 있고, 수정에 닫혀 있어야 함
    - 개발에 이용된 모듈 하나를 수정 했을 때, 해당 모듈이 사용된 다른 모듈을 전부 수정 해야 한다면, 코드를 수정 하기가 어려움
    - OCP가 잘 적용돼 있으면, 코드 수정 없이 새로운 코드를 추가함으로써 기능 추가, 변경이 가능함
  - ### 전략 패턴
    - 실행 중 알고리즘을 선택하도록 하는 디자인 패턴
      - 특정 계열 알고리즘을 정의
      - 알고리즘 캡슐화
      - 알고리즘을 계열 안에서 상호 교체가 가능하도록 설계

> ### 미켈란젤로와 시스티나 성당
> 
> "멀어서 보이지도 않는 천장 그림을 왜 그렇게 꼼꼼히 그리는거야?"
> 
> "하나님과 나는 보니까."

## 클린 코드, 리팩토링, 단위 테스트, 레거시 코드
  - 레거시 코드 수정을 검증하려면 단위 테스트가 필요
  - 단위 테스트를 레거시 코드에 넣으려면 리팩토링 필요
  - 리팩토링은 코드가 개선돼야 하므로 클린코드가 필수
  - 단위 테스트 자체도 범위와 기능이 늘어나므로 리팩토링 필요
  - 단위 테스트도 가독성이 높아야하므로 클린코드 필수

# 리팩토링

## 리팩토링이란?
  - 밖으로 드러나는 동작(기능)은 유지
  - 내부구조를 변경함으로써 코드를 재구성
   
## 왜 리팩토링 하는가?
  - 프로그램은 지속적으로 발전하게 됨 - 정적인 것이 아님
    - 스펙이 바뀌기 때문
    - 프로그램이 건축을 비유해서 많이 설명되지만 실제로는 정원 가꾸기에 가까움
      - 한 번 짓기 시작한 건축물은 설계를 바꿀 수 없음
      - 정원은 기분에 따라, 상황에 따라 위치와 재료들이 바뀔 수 있음
      - 그럼에도 건축에 비유되는 이유는 과학적이고, 반복적이며, 위계질서도 있어서...(그냥 간지나서...)

## 언제 리팩토링 하는가?
  - 중복
  - 직교적(독립적)이지 않은 설계
  - 더 이상 유효하지 않은 지식(더 좋은 라이브러리등)
  - 주기
    - 일찍 그리고 자주
    - 문제가 작을 떄, 빠르게
    - 일정에 리팩토링 시간을 포함시켜야 실현 가능

## 어떻게 리팩토링 하는가?
  - 리팩토링과 기능 추가를 동시에 하지않기
  - 리팩토링전 테스트 코드가 든든한 지 확인하기
  - 단계를 작게 나누고 신중하게 작업
    - 클래스 필드를 다른 클래스로
    - 메소드 하나를 여러 개로
    - 변수명 하나 바꾸기
  - 일부로 빌드를 깨보기
    - 대상 코드에 의존하는 코드를 쉽게 확인 할 수 있음
  - 고통 관리가 핵심
    - 지금 놔두면 점점 더 고통스러워질 뿐

# 단위 테스트

## 단위 테스트의 목표
  - 소프트웨어 동작을 기능적인 측면에서 검증, 문제를 즉시 찾을 수 있도록 함
    - E2E(End-to-End) 테스트가 아님
    - 개발자 주도 테스트임
    - 자동화 되어야함
    - **항상 커밋 전에 실행 할 것**
    - 마일스톤이나 이벤트가 아님
      - 단위 테스트도 항상 리팩토링과 스펙에 따른 변경이 필요함

## 단위 테스트의 핵심
  ### F.I.R.S.T.
  ```
  - Fast              빨라야 함
  - Independent       독립적으로 하나의 테스트가 다른테스트에 영향을 미치면 안됨
  - Repeatable        어떤 환경에서도 반복 가능하며 멱등성을 유지
  - Self-Validating   결과는 bool. 성공 OR 실패 
  - Timely            적시에, 테스트하려는 실제 코드를 구현하기 직전에 구현
  ```

## 테스트 자동화
  - 테스트는 자동화 돼서 작성해둔 테스트가 실제로 비용이 절감돼야 함
  - 즉, 현재 검증하는 비용이 10이라고 할 때, 15의 비용을 들여서 테스트를 작성해두면 이후에는 이전(10)보다는 낮은 비용을 들여 검증이 끝나야 함
  - 15의 비용을 들였는데 이후 검증이 이전(10)과 같거나 그 이상의 비용이 든다면 오히려 손해 본 것
  ![img.png](img.png)
    이처럼 자동화 된 테스트는 지속적으로 비용 절감에 도움이 됨

## 커버리지
  - 커버리지는 개발자 워크플로우에 상당한 이점을 제공
  - 커버리지가 높다고 품질이 좋은 프로그램은 아님
  - 하지만 커버리지가 낮은건 품질이 좋지 않은 프로그램임
  - 따라서 합리적인 커버리지를 찾는게 좋음
  - 모든 프로그램에서 이상적인 커버리지라는 것은 없음
  - 커버리지를 90%에서 95%로 가는 것에 집착하면 안 됨
  - 자주 변경되는 코드는 커버가 되는 것이 좋음
  - 커버리지는 단위 테스트의 한 조각일 뿐임

> ### 예) 오라클
> 
> 엄청난 양의 테스트를 통과하지 못하면 코드를 한 줄도 작성 불가능
> 
> 손으로 직접 써서 풀지 않으면 알 수 없는 매크로도 존재
> 
> 변경 사항을 테스트 팜에 넣으면 분산된 방식으로 테스트를 진행
> 
> 그리고 퇴근. 다음날 동작하는지 살펴보는 방식으로 개발
> 
> 완료까지 20~30시간정도 걸림
> 
> 하나의 작은 기능을 개발하는데 6개월에서 1,2년까지도 걸림

> ### 예) Microsoft Visual Studio Team Service
> 
> ### 2015년 
> 
> 수 만 개의 테스트가 존재
> 
> 개발자가 테스터를 위한 테스트 코드 작성
> 
> 테스트를 명확하게 측정 가능하고 테스트 분야의 전문성 성장 -> 개발자의 동기 부여 하락
> 
> 대부분 E2E 테스트
> 
> 소규모 변경에도 실행속도가 느린 테스트를 진행해야하고 결과 분석에도 오래걸림
> 
> ### 2017년 이후
> 
> 개발조직과 테스트 조직을 엔지니어링 조직으로 단일화
> 
> 모든 사람이 작업의 일부를 수행하고 결과물의 품질에 대해 책임
> 
> 8년간의 테스트를 모두 폐기
> 
> E2E 테스트를 획기적으로 줄이고 단위 테스트 자동화에 집중

## 단위 테스트의 분파
  - 디트로이트 파
    - 테스트와 협력자를 동시에 운용
    - 테스트끼리 공유하는 의존성에 대해서만 대역을 사용
    - 빠르고 효율적인 테스트
  - 런던 파
    - 테스트와 협력자를 격리
    - 불변 의존성을 제외한 모든 의존성을 대역(mock)으로 처리
    - 외부 영향으로부터 분리해 테스트 대상의 기능에만 초점을 맞춘다

  > 스터디 내용~


# 레거시 코드
  - 현재는 잘 돌아가는 비지니스의 원동력
  - 스펙, 환경, 성능, 스택의 변화로 필연적으로 변경이 일어남
  - 레거시 변경은 최소로 하는 것을 권장
  - 레거시 변경은 리팩토링이 선행 돼야함
  - 가장 두려운것은 `Side Effect`

## 레거시 코드에 대한 대처
  - 레거시 코드가 펌웨어화 되어 낡아가는 것을 지속적으로 방지
  - 리팩토링 또는 기능을 추가시
    - 테스트가 가능 해야 함
    - 가독성을 높여 가야 함

## 레거시 코드로 남지 않기 위한 대처
  - 켄트 백이 제시한 세 가지 방법
    - 동작하기 -> 기능 개발의 필수 요건
    - 올바르게 만들기 -> 기능 개선
    - 빠르게 만들기 -> 성능 개선
